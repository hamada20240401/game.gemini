<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Siamese Cat Stroll 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #B2F0F5; /* ãƒãƒƒãƒ—ãªç©ºã®è‰² */
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #555;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: none;
            user-select: none;
        }
        h1 {
            margin: 0 0 5px 0;
            font-size: 1.5rem;
            color: #FF7E79;
        }
        p { margin: 0; font-size: 0.9rem; }
        .key {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8rem;
            margin: 0 2px;
            font-weight: bold;
        }
        #interaction-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #FF3B30;
            text-shadow: 2px 2px 0 #FFF;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            pointer-events: none;
            white-space: nowrap;
        }
        #interaction-msg.show {
            opacity: 1;
            transform: translate(-50%, -60%) scale(1.2);
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>ğŸ¾ ã‚·ãƒ£ãƒ çŒ«ã•ã‚“ã½</h1>
        <p>æ“ä½œ: <span class="key">â†</span> <span class="key">â†‘</span> <span class="key">â†“</span> <span class="key">â†’</span> ã¾ãŸã¯ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°</p>
        <p>ä»–ã®çŒ«ã«è¿‘ã¥ãã¨...ï¼Ÿ</p>
    </div>

    <div id="interaction-msg">ã‚·ãƒ£ãƒ¼ãƒƒï¼ï¼ğŸ’¢</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- è¨­å®š ---
        const COLORS = {
            sky: 0xB2F0F5,
            ground: 0xFFF8E7, // ã‚¯ãƒªãƒ¼ãƒ è‰²
            building: [0xFFDAC1, 0xE2F0CB, 0xB5EAD7, 0xC7CEEA], // ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼
            siameseBody: 0xE6D2B5, // ã‚·ãƒ£ãƒ çŒ«ã®ä½“
            siamesePoint: 0x4B3621, // ã‚·ãƒ£ãƒ çŒ«ã®ç„¦ã’èŒ¶ãƒã‚¤ãƒ³ãƒˆ
            catColors: [0xFFA07A, 0x808080, 0x000000, 0xFFD700] // ä»–ã®çŒ«ã®è‰²
        };

        // --- ã‚·ãƒ¼ãƒ³ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.sky);
        scene.fog = new THREE.Fog(COLORS.sky, 20, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- ãƒ©ã‚¤ãƒˆ ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        scene.add(dirLight);

        // --- åœ°é¢ ---
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const groundMat = new THREE.MeshStandardMaterial({ color: COLORS.ground });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆé–¢æ•°: çŒ« ---
        function createCat(isPlayer = false, colorOverride = null) {
            const catGroup = new THREE.Group();

            // è‰²ã®è¨­å®šï¼ˆã‚·ãƒ£ãƒ çŒ«ã‹ã€ãƒ©ãƒ³ãƒ€ãƒ ãªé‡è‰¯çŒ«ã‹ï¼‰
            const bodyColor = isPlayer ? COLORS.siameseBody : (colorOverride || 0x888888);
            const pointColor = isPlayer ? COLORS.siamesePoint : bodyColor; // é‡è‰¯çŒ«ã¯å˜è‰²

            const materialBody = new THREE.MeshStandardMaterial({ color: bodyColor });
            const materialPoint = new THREE.MeshStandardMaterial({ color: pointColor });

            // ä½“
            const bodyGeo = new THREE.CapsuleGeometry(0.6, 1.2, 4, 8);
            const body = new THREE.Mesh(bodyGeo, materialBody);
            body.rotation.z = Math.PI / 2;
            body.position.y = 0.8;
            body.castShadow = true;
            catGroup.add(body);

            // é ­
            const headGeo = new THREE.SphereGeometry(0.7, 16, 16);
            const head = new THREE.Mesh(headGeo, isPlayer ? materialBody : materialBody); // ã‚·ãƒ£ãƒ çŒ«ã®é ­ã¯ä½“ã¨åŒã˜
            head.position.set(0.9, 1.4, 0);
            head.castShadow = true;
            catGroup.add(head);

            // è€³ (å·¦)
            const earGeo = new THREE.ConeGeometry(0.25, 0.5, 8);
            const earL = new THREE.Mesh(earGeo, materialPoint);
            earL.position.set(0.9, 2.0, 0.3);
            earL.rotation.z = -0.2;
            earL.rotation.x = 0.2;
            catGroup.add(earL);

            // è€³ (å³)
            const earR = new THREE.Mesh(earGeo, materialPoint);
            earR.position.set(0.9, 2.0, -0.3);
            earR.rotation.z = -0.2;
            earR.rotation.x = -0.2;
            catGroup.add(earR);

            // é¡”ï¼ˆã‚·ãƒ£ãƒ çŒ«ã®é¡”ã®ä¸­å¿ƒã‚’é»’ãã™ã‚‹è¡¨ç¾ã¯ç°¡æ˜“çš„ã«é¼»å…ˆã§ä»£ç”¨ï¼‰
            if(isPlayer) {
                const faceMaskGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const faceMask = new THREE.Mesh(faceMaskGeo, materialPoint);
                faceMask.position.set(1.15, 1.4, 0);
                faceMask.scale.set(0.5, 0.8, 0.8);
                catGroup.add(faceMask);
            }

            // å°»å°¾
            const tailGeo = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
            const tail = new THREE.Mesh(tailGeo, materialPoint);
            tail.position.set(-1.0, 1.2, 0);
            tail.rotation.z = 0.8;
            catGroup.add(tail);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
            catGroup.userData = {
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3(1, 0, 0),
                isHissing: false,
                hissTimer: 0,
                baseY: 0,
                hopOffset: 0
            };

            return catGroup;
        }

        // --- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆé–¢æ•°: å»ºç‰© ---
        function createCity() {
            const cityGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            for (let i = 0; i < 40; i++) {
                const color = COLORS.building[Math.floor(Math.random() * COLORS.building.length)];
                const material = new THREE.MeshStandardMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);

                // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚µã‚¤ã‚ºã¨ä½ç½®
                const h = 2 + Math.random() * 6;
                const w = 2 + Math.random() * 3;
                const d = 2 + Math.random() * 3;
                
                mesh.scale.set(w, h, d);
                
                // ä¸­å¿ƒï¼ˆ0,0ï¼‰ä»˜è¿‘ã¯é¿ã‘ã‚‹
                let x = (Math.random() - 0.5) * 80;
                let z = (Math.random() - 0.5) * 80;
                if (Math.abs(x) < 5 && Math.abs(z) < 5) x += 10;

                mesh.position.set(x, h/2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                cityGroup.add(mesh);
            }
            return cityGroup;
        }

        // --- ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ– ---
        const city = createCity();
        scene.add(city);

        // ä¸»äººå…¬ï¼ˆã‚·ãƒ£ãƒ çŒ«ï¼‰
        const player = createCat(true);
        scene.add(player);

        // ä»–ã®çŒ«ãŸã¡
        const npcs = [];
        for(let i=0; i<8; i++) {
            const color = COLORS.catColors[i % COLORS.catColors.length];
            const npc = createCat(false, color);
            // ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
            npc.position.set(
                (Math.random() - 0.5) * 60,
                0,
                (Math.random() - 0.5) * 60
            );
            // ãƒ©ãƒ³ãƒ€ãƒ ãªå‘ã
            npc.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(npc);
            npcs.push(npc);
        }

        // --- æ“ä½œç³» ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w:false, a:false, s:false, d:false };
        
        window.addEventListener('keydown', (e) => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (e) => {
            if(keys.hasOwnProperty(e.key)) keys[e.key] = false;
            if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false;
        });

        // ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ï¼ˆãƒã‚¦ã‚¹æ“ä½œç”¨ï¼‰
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // åœ°é¢ã‚ˆã‚Šä¸‹ã«è¡Œã‹ãªã„

        // UIè¦ç´ 
        const msgEl = document.getElementById('interaction-msg');

        // --- ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ— ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•å‡¦ç†
            const speed = 8 * delta;
            const turnSpeed = 4 * delta;
            let moving = false;

            if (keys.ArrowUp || keys.w) {
                player.translateX(speed);
                moving = true;
            }
            if (keys.ArrowDown || keys.s) {
                player.translateX(-speed * 0.6);
                moving = true;
            }
            if (keys.ArrowLeft || keys.a) {
                player.rotation.y += turnSpeed;
            }
            if (keys.ArrowRight || keys.d) {
                player.rotation.y -= turnSpeed;
            }

            // æ­©è¡Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã´ã‚‡ã“ã´ã‚‡ã“è·³ã­ã‚‹ï¼‰
            if (moving) {
                player.position.y = Math.abs(Math.sin(time * 10)) * 0.3;
            } else {
                player.position.y = 0;
            }

            // 2. ã‚«ãƒ¡ãƒ©è¿½å¾“
            // ã‚«ãƒ¡ãƒ©ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¾Œã‚ä¸Šæ–¹ã«ã‚¹ãƒ ãƒ¼ã‚ºã«è¿½å¾“ã•ã›ã‚‹ç°¡æ˜“å®Ÿè£…
            const relativeCameraOffset = new THREE.Vector3(-8, 5, 0); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®èƒŒå¾Œ
            const cameraOffset = relativeCameraOffset.applyMatrix4(player.matrixWorld);
            
            // OrbitControlsã‚’ä½¿ã£ã¦ã„ã‚‹å ´åˆã€targetã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã™ã‚‹
            controls.target.lerp(player.position, 0.1);
            controls.update();


            // 3. NPCã®å‹•ãã¨è¡çªåˆ¤å®š
            let interactionHappened = false;

            npcs.forEach(npc => {
                // å¨åš‡ä¸­ã¯å‹•ã‹ãªã„
                if (npc.userData.isHissing) {
                    npc.userData.hissTimer -= delta;
                    
                    // å¨åš‡ã®å‹•ãï¼ˆæŒ¯å‹•ï¼‰
                    npc.rotation.z = Math.sin(time * 30) * 0.1;
                    npc.scale.setScalar(1.2); // å¤§ãããªã‚‹

                    if (npc.userData.hissTimer <= 0) {
                        npc.userData.isHissing = false;
                        npc.scale.setScalar(1);
                        npc.rotation.z = 0;
                    }
                } else {
                    // é€šå¸¸ç§»å‹•ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯ï¼‰
                    npc.translateX(2 * delta);
                    
                    // æ™‚ã€…å‘ãã‚’å¤‰ãˆã‚‹
                    if (Math.random() < 0.02) {
                        npc.rotation.y += (Math.random() - 0.5) * 2;
                    }

                    // å£ï¼ˆåŸç‚¹ã‹ã‚‰ã®è·é›¢ï¼‰ã«è¡ŒãéããŸã‚‰æˆ»ã‚‹
                    if (npc.position.length() > 40) {
                        npc.lookAt(0,0,0);
                    }
                }

                // è¡çªåˆ¤å®šï¼ˆè·é›¢ãƒã‚§ãƒƒã‚¯ï¼‰
                const dist = player.position.distanceTo(npc.position);
                if (dist < 3.5 && !npc.userData.isHissing) {
                    // å¨åš‡é–‹å§‹
                    npc.userData.isHissing = true;
                    npc.userData.hissTimer = 1.5; // 1.5ç§’é–“å¨åš‡
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ–¹ã‚’å‘ã
                    npc.lookAt(player.position.x, player.position.y, player.position.z);
                    
                    interactionHappened = true;
                }
            });

            // UIè¡¨ç¤ºæ›´æ–°
            if (interactionHappened) {
                msgEl.classList.add('show');
                // æ•°ç§’å¾Œã«æ¶ˆã™å‡¦ç†ã¯CSS transitionã¨JSã®ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†ãŒå¿…è¦ã ãŒ
                // ã“ã“ã§ã¯å˜ç´”ã«ãƒ’ãƒƒãƒˆã—ãŸç¬é–“ã ã‘ã‚¯ãƒ©ã‚¹ã‚’ã¤ã‘ã‚‹ï¼ˆé€£ç¶šãƒ’ãƒƒãƒˆã§ç¶­æŒã•ã‚Œã‚‹ï¼‰
                clearTimeout(window.hideMsgTimer);
                window.hideMsgTimer = setTimeout(() => {
                    msgEl.classList.remove('show');
                }, 1000);
            }

            renderer.render(scene, camera);
        }

        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>